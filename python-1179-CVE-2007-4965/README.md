# [python-1179](https://bugs.python.org/issue1179)
- behavior: SIGABRT
- description: feed `imageop_tovideo` with negative integer to make integer overflow happen so that internal validity checking is fooled.
- sketch:

    - `PyEval_EvalFrame` at Python/ceval.c:2167
    
        **case CALL_FUNCTION** call `imageop_tovideo`
        
        `x = call_function(&sp, oparg);`

        - `call_function` at Python/ceval.c:3568
        
            `C_TRACE(x, PyCFunction_Call(func,callargs,NULL));`

            *i.e.* `x = PyCFunction_Call(func,callargs,NULL));` in this case.

            - `PyCFunction_Call` at Objects/methodobject.c:73

                `return (*meth)(self, arg);`
                 
                where `meth = ((PyCFunctionObject *)func) -> m_ml -> ml_meth`

                - `imageop_tovideo` at Modules/imageop.c:
                
                    First, four arguments(image, psize, width, height) are parsed into (cp, width, maxx, maxy). `len` record the length of `cp`. Then it checks if `maxx*maxy*width == len`, *i.e.* the length of string representing images matches the width, height, and pixel size. Obviously, `maxy < 0` is not a valid argument, but integer overflow results in `maxx*maxy*width == len`.

                    `rv = PyString_FromStringAndSize(NULL, len);`

                    Initialize a `PyStringObject` with a string of lenght `len`. Here, `(PyStringObject *)rv->ob_size = len`

                    `ncp = (unsigned char *)PyString_AsString(rv);`

                    `ncp` now is a null-terminated representation of that string, (instead of a copy), so that the data could be manipulated later through `ncp`.

                    ```C
                    memcpy(ncp, cp, maxx);      /* Copy first line */
                    ncp += maxx;
                    for (y=1; y<maxy; y++) {    /* Interpolate other lines */
                        for(x=0; x<maxx; x++) {
                            i = y*maxx + x;
                            *ncp++ = ((int)cp[i] + (int)cp[i-maxx]) >> 1;
                        }
                    }
                    ```

                    The code snippet here is to interpolate `cp` and store the result in `ncp`. However, `maxx = 4461`, which is out of the range of memory allocated to either `ncp` or `cp`. That may corrupt the memory space in some undefined way.

        `PUSH(x);` *i.e.* `*stack_pointer++ = x` 

        **case STORE_NAME** store the return value of `imageop_tovideo` to `dtc`

        `w = GETITEM(names, oparg);` *i.e.* `w = ((PyTupleObject *)names) -> ob_item[oparg]`

        `names` is a tuple of all variable name in python local scope. `w` now refers to a `PyStringObject` with data `dtc`(recall in poc.py, we have `dtc = imageop.tovideo(sexshit,1,4461,-2147002257)`)

        `v = POP();` *i.e.* `v = *--stack_pointer`

        `v` is exactly `rv`, the 'return value` of `CALL_FUNCTION`.

        `err = PyDict_SetItem(x, w, v);`

        Bound return value `rv` to variable `dtc` in local scope `x`.

        **case LOAD_CONST** make string "dtc" a `PyStringObject` and load it in stack

        **case LOAD_CONST** make integer 52 a `PyIntObject` and load it in stack

        **case BINARY_MULTIPLY** pop "dtc" and 52 out of stack, multiply them, make result into a new `PyStringObject` and put into stack.

        **case STORE_NAME** store the result of multiplication to `dtc`

        `err = PyDict_SetItem(x, w, v);`

        - `PyDict_SetItem(op, key, value)` at Objects/dictobject.c:589

            `mp = (dictobject *)op;`

            `insertdict(mp, key, hash, value);`

            - `insertdic(mp, key, value)` at Objects/dictobject.c:405

                ```C
                ep = mp->ma_lookup(mp, key, hash);
                if (ep->me_value != NULL) {
                    old_value = ep->me_value;
                    ep->me_value = value;
                    Py_DECREF(old_value); /* which **CAN** re-enter */
                    Py_DECREF(key);
                }
                ```

                in which `#define Py_DECREF(op) if (_Py_DEC_REFTOTAL _Py_REF_DEBUG_COMMA --(op)->ob_refcnt != 0) _Py_CHECK_REFCNT(op) else _Py_Dealloc((PyObject *)(op))`

                Since `sexshit` is already in the local scope, we have to `Py_DECREF` the object it refers to, *i.e.* `old_value`. And because `old_value` has no other reference, python decide to deallocate the memory. 
                
                - `_Py_Dealloc` at Objects/object.c:1884

                    - `string_dealloc` at Objects/stringobject.c:512

                        - `_PyObject_DebugFree` at Objects/obmalloc.c:1044

                            `PyObject_Free(q-8)`

                            - `PyObject_Free(p)` at Objects/obmalloc.c:798

                                `free(p);`
                
                                It seems that `free()` uses not only the memory address but also the memory around the allocated ones to collect information about the memory. In this way, system could know exactly how to free that memory. However, it seems that such additional information is corrupted by previous `memcpy`. Therefore, we have error "free(): corrupted unsorted chunks"

- patch: [Add integer overflow checking at multiple places](https://hg.python.org/cpython/rev/8d6e2499726a)
