diff --git a/Zend/zend_float.h b/Zend/zend_float.h
index f32c72e3..369fee91 100644
--- a/Zend/zend_float.h
+++ b/Zend/zend_float.h
@@ -74,329 +74,6 @@ END_EXTERN_C()
     http://msdn.microsoft.com/en-us/library/c9676k6h(v=vs.110).aspx
 */
 
-/* MSVC detection (MSVC people usually don't use autoconf) */
-#if defined(_MSC_VER) && !defined(_WIN64)
-#  define HAVE__CONTROLFP_S
-#endif /* _MSC_VER */
-
-#ifdef HAVE__CONTROLFP_S
-
-/* float.h defines _controlfp_s */
-# include <float.h>
-
-# define XPFPA_HAVE_CW 1
-# define XPFPA_CW_DATATYPE \
-            unsigned int
-
-# define XPFPA_STORE_CW(vptr) do { \
-            _controlfp_s((unsigned int *)(vptr), 0, 0); \
-        } while (0)
-
-# define XPFPA_RESTORE_CW(vptr) do { \
-            unsigned int _xpfpa_fpu_cw; \
-            _controlfp_s(&_xpfpa_fpu_cw, *((unsigned int *)(vptr)), _MCW_PC); \
-        } while (0)
-
-# define XPFPA_DECLARE \
-            unsigned int _xpfpa_fpu_oldcw, _xpfpa_fpu_cw;
-
-# define XPFPA_SWITCH_DOUBLE() do { \
-            _controlfp_s(&_xpfpa_fpu_cw, 0, 0); \
-            _xpfpa_fpu_oldcw = _xpfpa_fpu_cw; \
-            _controlfp_s(&_xpfpa_fpu_cw, _PC_53, _MCW_PC); \
-        } while (0)
-# define XPFPA_SWITCH_SINGLE() do { \
-            _controlfp_s(&_xpfpa_fpu_cw, 0, 0); \
-            _xpfpa_fpu_oldcw = _xpfpa_fpu_cw; \
-            _controlfp_s(&_xpfpa_fpu_cw, _PC_24, _MCW_PC); \
-        } while (0)
-/* NOTE: This only sets internal precision. MSVC does NOT support double-
-   extended precision! */
-# define XPFPA_SWITCH_DOUBLE_EXTENDED() do { \
-            _controlfp_s(&_xpfpa_fpu_cw, 0, 0); \
-            _xpfpa_fpu_oldcw = _xpfpa_fpu_cw; \
-            _controlfp_s(&_xpfpa_fpu_cw, _PC_64, _MCW_PC); \
-        } while (0)
-# define XPFPA_RESTORE() \
-            _controlfp_s(&_xpfpa_fpu_cw, _xpfpa_fpu_oldcw, _MCW_PC)
-/* We do NOT use the volatile return trick since _controlfp_s is a function
-   call and thus FP registers are saved in memory anyway. However, we do use
-   a variable to ensure that the expression passed into val will be evaluated
-   *before* switching back contexts. */
-# define XPFPA_RETURN_DOUBLE(val) \
-            do { \
-                double _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-# define XPFPA_RETURN_SINGLE(val) \
-            do { \
-                float _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-/* This won't work, but we add a macro for it anyway. */
-# define XPFPA_RETURN_DOUBLE_EXTENDED(val) \
-            do { \
-                long double _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-
-#elif defined(HAVE__CONTROLFP)
-
-/* float.h defines _controlfp */
-# include <float.h>
-
-# define XPFPA_DECLARE \
-            unsigned int _xpfpa_fpu_oldcw;
-
-# define XPFPA_HAVE_CW 1
-# define XPFPA_CW_DATATYPE \
-            unsigned int
-
-# define XPFPA_STORE_CW(vptr) do { \
-            *((unsigned int *)(vptr)) = _controlfp(0, 0); \
-        } while (0)
-
-# define XPFPA_RESTORE_CW(vptr) do { \
-            _controlfp(*((unsigned int *)(vptr)), _MCW_PC); \
-        } while (0)
-
-# define XPFPA_SWITCH_DOUBLE() do { \
-            _xpfpa_fpu_oldcw = _controlfp(0, 0); \
-            _controlfp(_PC_53, _MCW_PC); \
-        } while (0)
-# define XPFPA_SWITCH_SINGLE() do { \
-            _xpfpa_fpu_oldcw = _controlfp(0, 0); \
-            _controlfp(_PC_24, _MCW_PC); \
-        } while (0)
-/* NOTE: This will only work as expected on MinGW. */
-# define XPFPA_SWITCH_DOUBLE_EXTENDED() do { \
-            _xpfpa_fpu_oldcw = _controlfp(0, 0); \
-            _controlfp(_PC_64, _MCW_PC); \
-        } while (0)
-# define XPFPA_RESTORE() \
-            _controlfp(_xpfpa_fpu_oldcw, _MCW_PC)
-/* We do NOT use the volatile return trick since _controlfp is a function
-   call and thus FP registers are saved in memory anyway. However, we do use
-   a variable to ensure that the expression passed into val will be evaluated
-   *before* switching back contexts. */
-# define XPFPA_RETURN_DOUBLE(val) \
-            do { \
-                double _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-# define XPFPA_RETURN_SINGLE(val) \
-            do { \
-                float _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-/* This will only work on MinGW */
-# define XPFPA_RETURN_DOUBLE_EXTENDED(val) \
-            do { \
-                long double _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-
-#elif defined(HAVE__FPU_SETCW) /* glibc systems */
-
-/* fpu_control.h defines _FPU_[GS]ETCW */
-# include <fpu_control.h>
-
-# define XPFPA_DECLARE \
-            fpu_control_t _xpfpa_fpu_oldcw, _xpfpa_fpu_cw;
-
-# define XPFPA_HAVE_CW 1
-# define XPFPA_CW_DATATYPE \
-            fpu_control_t
-
-# define XPFPA_STORE_CW(vptr) do { \
-            _FPU_GETCW((*((fpu_control_t *)(vptr)))); \
-        } while (0)
-
-# define XPFPA_RESTORE_CW(vptr) do { \
-            _FPU_SETCW((*((fpu_control_t *)(vptr)))); \
-        } while (0)
-
-# define XPFPA_SWITCH_DOUBLE() do { \
-            _FPU_GETCW(_xpfpa_fpu_oldcw); \
-            _xpfpa_fpu_cw = (_xpfpa_fpu_oldcw & ~_FPU_EXTENDED & ~_FPU_SINGLE) | _FPU_DOUBLE; \
-            _FPU_SETCW(_xpfpa_fpu_cw); \
-        } while (0)
-# define XPFPA_SWITCH_SINGLE() do { \
-            _FPU_GETCW(_xpfpa_fpu_oldcw); \
-            _xpfpa_fpu_cw = (_xpfpa_fpu_oldcw & ~_FPU_EXTENDED & ~_FPU_DOUBLE) | _FPU_SINGLE; \
-            _FPU_SETCW(_xpfpa_fpu_cw); \
-        } while (0)
-# define XPFPA_SWITCH_DOUBLE_EXTENDED()  do { \
-            _FPU_GETCW(_xpfpa_fpu_oldcw); \
-            _xpfpa_fpu_cw = (_xpfpa_fpu_oldcw & ~_FPU_SINGLE & ~_FPU_DOUBLE) | _FPU_EXTENDED; \
-            _FPU_SETCW(_xpfpa_fpu_cw); \
-        } while (0)
-# define XPFPA_RESTORE() \
-            _FPU_SETCW(_xpfpa_fpu_oldcw)
-/* We use a temporary volatile variable (in a new block) in order to ensure
-   that the optimizer does not mis-optimize the instructions. Also, a volatile
-   variable ensures truncation to correct precision. */
-# define XPFPA_RETURN_DOUBLE(val) \
-            do { \
-                volatile double _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-# define XPFPA_RETURN_SINGLE(val) \
-            do { \
-                volatile float _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-# define XPFPA_RETURN_DOUBLE_EXTENDED(val) \
-            do { \
-                volatile long double _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-
-#elif defined(HAVE_FPSETPREC) /* FreeBSD */
-
-/* fpu_control.h defines _FPU_[GS]ETCW */
-# include <machine/ieeefp.h>
-
-# define XPFPA_DECLARE \
-            fp_prec_t _xpfpa_fpu_oldprec;
-
-# define XPFPA_HAVE_CW 1
-# define XPFPA_CW_DATATYPE \
-            fp_prec_t
-
-# define XPFPA_STORE_CW(vptr) do { \
-            *((fp_prec_t *)(vptr)) = fpgetprec(); \
-        } while (0)
-
-# define XPFPA_RESTORE_CW(vptr) do { \
-            fpsetprec(*((fp_prec_t *)(vptr))); \
-        } while (0)
-
-# define XPFPA_SWITCH_DOUBLE() do { \
-            _xpfpa_fpu_oldprec = fpgetprec(); \
-            fpsetprec(FP_PD); \
-        } while (0)
-# define XPFPA_SWITCH_SINGLE() do { \
-            _xpfpa_fpu_oldprec = fpgetprec(); \
-            fpsetprec(FP_PS); \
-        } while (0)
-# define XPFPA_SWITCH_DOUBLE_EXTENDED() do { \
-            _xpfpa_fpu_oldprec = fpgetprec(); \
-            fpsetprec(FP_PE); \
-        } while (0)
-# define XPFPA_RESTORE() \
-            fpsetprec(_xpfpa_fpu_oldprec)
-/* We use a temporary volatile variable (in a new block) in order to ensure
-   that the optimizer does not mis-optimize the instructions. Also, a volatile
-   variable ensures truncation to correct precision. */
-# define XPFPA_RETURN_DOUBLE(val) \
-            do { \
-                volatile double _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-# define XPFPA_RETURN_SINGLE(val) \
-            do { \
-                volatile float _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-# define XPFPA_RETURN_DOUBLE_EXTENDED(val) \
-            do { \
-                volatile long double _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-
-#elif defined(HAVE_FPU_INLINE_ASM_X86)
-
-/*
-  Custom x86 inline assembler implementation.
-
-  This implementation does not use predefined wrappers of the OS / compiler
-  but rather uses x86/x87 inline assembler directly. Basic instructions:
-
-  fnstcw - Store the FPU control word in a variable
-  fldcw  - Load the FPU control word from a variable
-
-  Bits (only bits 8 and 9 are relevant, bits 0 to 7 are for other things):
-     0x0yy: Single precision
-     0x1yy: Reserved
-     0x2yy: Double precision
-     0x3yy: Double-extended precision
-
-  We use an unsigned int for the datatype. glibc sources add __mode__ (__HI__)
-  attribute to it (HI stands for half-integer according to docs). It is unclear
-  what the does exactly and how portable it is.
-
-  The assembly syntax works with GNU CC, Intel CC and Sun CC.
-*/
-
-# define XPFPA_DECLARE \
-            unsigned int _xpfpa_fpu_oldcw, _xpfpa_fpu_cw;
-
-# define XPFPA_HAVE_CW 1
-# define XPFPA_CW_DATATYPE \
-            unsigned int
-
-# define XPFPA_STORE_CW(vptr) do { \
-            __asm__ __volatile__ ("fnstcw %0" : "=m" (*((unsigned int *)(vptr)))); \
-        } while (0)
-
-# define XPFPA_RESTORE_CW(vptr) do { \
-            __asm__ __volatile__ ("fldcw %0" : : "m" (*((unsigned int *)(vptr)))); \
-        } while (0)
-
-# define XPFPA_SWITCH_DOUBLE() do { \
-            __asm__ __volatile__ ("fnstcw %0" : "=m" (*&_xpfpa_fpu_oldcw)); \
-            _xpfpa_fpu_cw = (_xpfpa_fpu_oldcw & ~0x100) | 0x200; \
-            __asm__ __volatile__ ("fldcw %0" : : "m" (*&_xpfpa_fpu_cw)); \
-        } while (0)
-# define XPFPA_SWITCH_SINGLE() do { \
-            __asm__ __volatile__ ("fnstcw %0" : "=m" (*&_xpfpa_fpu_oldcw)); \
-            _xpfpa_fpu_cw = (_xpfpa_fpu_oldcw & ~0x300); \
-            __asm__ __volatile__ ("fldcw %0" : : "m" (*&_xpfpa_fpu_cw)); \
-        } while (0)
-# define XPFPA_SWITCH_DOUBLE_EXTENDED() do { \
-            __asm__ __volatile__ ("fnstcw %0" : "=m" (*&_xpfpa_fpu_oldcw)); \
-            _xpfpa_fpu_cw = _xpfpa_fpu_oldcw | 0x300; \
-            __asm__ __volatile__ ("fldcw %0" : : "m" (*&_xpfpa_fpu_cw)); \
-        } while (0)
-# define XPFPA_RESTORE() \
-            __asm__ __volatile__ ("fldcw %0" : : "m" (*&_xpfpa_fpu_oldcw))
-/* We use a temporary volatile variable (in a new block) in order to ensure
-   that the optimizer does not mis-optimize the instructions. Also, a volatile
-   variable ensures truncation to correct precision. */
-# define XPFPA_RETURN_DOUBLE(val) \
-            do { \
-                volatile double _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-# define XPFPA_RETURN_SINGLE(val) \
-            do { \
-                volatile float _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-# define XPFPA_RETURN_DOUBLE_EXTENDED(val) \
-            do { \
-                volatile long double _xpfpa_result = (val); \
-                XPFPA_RESTORE(); \
-                return _xpfpa_result; \
-            } while (0)
-
-#else /* FPU CONTROL */
-
 /*
   This is either not an x87 FPU or the inline assembly syntax was not
   recognized. In any case, default to NOPs for the macros and hope the
@@ -415,6 +92,4 @@ END_EXTERN_C()
 # define XPFPA_RETURN_SINGLE(val)           return (val)
 # define XPFPA_RETURN_DOUBLE_EXTENDED(val)  return (val)
 
-#endif /* FPU CONTROL */
-
 #endif
diff --git a/Zend/zend_multiply.h b/Zend/zend_multiply.h
index e156d33a..00256ba0 100644
--- a/Zend/zend_multiply.h
+++ b/Zend/zend_multiply.h
@@ -117,140 +117,6 @@
 
 #endif
 
-#if defined(__GNUC__) && (defined(__native_client__) || defined(i386))
-
-static zend_always_inline size_t zend_safe_address(size_t nmemb, size_t size, size_t offset, int *overflow)
-{
-	size_t res = nmemb;
-	size_t m_overflow = 0;
-
-	__asm__ ("mull %3\n\taddl %4,%0\n\tadcl $0,%1"
-	     : "=&a"(res), "=&d" (m_overflow)
-	     : "%0"(res),
-	       "rm"(size),
-	       "rm"(offset));
-
-	if (UNEXPECTED(m_overflow)) {
-		*overflow = 1;
-		return 0;
-	}
-	*overflow = 0;
-	return res;
-}
-
-#elif defined(__GNUC__) && defined(__x86_64__)
-
-static zend_always_inline size_t zend_safe_address(size_t nmemb, size_t size, size_t offset, int *overflow)
-{
-	size_t res = nmemb;
-	zend_ulong m_overflow = 0;
-
-#ifdef __ILP32__ /* x32 */
-# define LP_SUFF "l"
-#else /* amd64 */
-# define LP_SUFF "q"
-#endif
-
-	__asm__ ("mul" LP_SUFF  " %3\n\t"
-		"add %4,%0\n\t"
-		"adc $0,%1"
-		: "=&a"(res), "=&d" (m_overflow)
-		: "%0"(res),
-		  "rm"(size),
-		  "rm"(offset));
-
-#undef LP_SUFF
-	if (UNEXPECTED(m_overflow)) {
-		*overflow = 1;
-		return 0;
-	}
-	*overflow = 0;
-	return res;
-}
-
-#elif defined(__GNUC__) && defined(__arm__)
-
-static zend_always_inline size_t zend_safe_address(size_t nmemb, size_t size, size_t offset, int *overflow)
-{
-	size_t res;
-	zend_ulong m_overflow;
-
-	__asm__ ("umlal %0,%1,%2,%3"
-		: "=r"(res), "=r"(m_overflow)
-		: "r"(nmemb),
-		  "r"(size),
-		  "0"(offset),
-		  "1"(0));
-
-	if (UNEXPECTED(m_overflow)) {
-		*overflow = 1;
-		return 0;
-	}
-	*overflow = 0;
-	return res;
-}
-
-#elif defined(__GNUC__) && defined(__aarch64__)
-
-static zend_always_inline size_t zend_safe_address(size_t nmemb, size_t size, size_t offset, int *overflow)
-{
-	size_t res;
-	zend_ulong m_overflow;
-
-	__asm__ ("mul %0,%2,%3\n\tumulh %1,%2,%3\n\tadds %0,%0,%4\n\tadc %1,%1,xzr"
-		: "=&r"(res), "=&r"(m_overflow)
-		: "r"(nmemb),
-		  "r"(size),
-		  "r"(offset));
-
-	if (UNEXPECTED(m_overflow)) {
-		*overflow = 1;
-		return 0;
-	}
-	*overflow = 0;
-	return res;
-}
-
-#elif defined(__GNUC__) && defined(__powerpc64__)
-
-static zend_always_inline size_t zend_safe_address(size_t nmemb, size_t size, size_t offset, int *overflow)
-{
-        size_t res;
-        unsigned long m_overflow;
-
-        __asm__ ("mulld %0,%2,%3\n\t"
-                 "mulhdu %1,%2,%3\n\t"
-                 "addc %0,%0,%4\n\t"
-                 "addze %1,%1\n"
-             : "=&r"(res), "=&r"(m_overflow)
-             : "r"(nmemb),
-               "r"(size),
-               "r"(offset));
-
-        if (UNEXPECTED(m_overflow)) {
-                *overflow = 1;
-                return 0;
-        }
-        *overflow = 0;
-        return res;
-}
-
-#elif SIZEOF_SIZE_T == 4
-
-static zend_always_inline size_t zend_safe_address(size_t nmemb, size_t size, size_t offset, int *overflow)
-{
-	uint64_t res = (uint64_t) nmemb * (uint64_t) size + (uint64_t) offset;
-
-	if (UNEXPECTED(res > UINT64_C(0xFFFFFFFF))) {
-		*overflow = 1;
-		return 0;
-	}
-	*overflow = 0;
-	return (size_t) res;
-}
-
-#else
-
 static zend_always_inline size_t zend_safe_address(size_t nmemb, size_t size, size_t offset, int *overflow)
 {
 	size_t res = nmemb * size + offset;
@@ -264,7 +130,6 @@ static zend_always_inline size_t zend_safe_address(size_t nmemb, size_t size, si
 	*overflow = 0;
 	return res;
 }
-#endif
 
 static zend_always_inline size_t zend_safe_address_guarded(size_t nmemb, size_t size, size_t offset)
 {
